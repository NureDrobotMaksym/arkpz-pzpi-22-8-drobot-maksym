Міністерство освіти і науки України
Харківський національний університет радіоелектроніки




Кафедра програмної інженерії




ЗВІТ
 з практичної роботи №2
з дисципліни «Аналіз та рефакторинг коду»
на тему «Методи рефакторингу коду програмного забезпечення»




Виконав:										 Перевірив:
ст. гр. ПЗПІ-22-8								  ст. викл. каф. ПІ
Дробот Максим Євгенович				         Сокорчук Ігор Петрович







Харків 2024
2 МЕТОДИ РЕФАКТОРИНГУ КОДУ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ


	2.1 Мета роботи
	Ознайомитись з основними методами рефакторингу коду на основі реальних прикладів з власних програмних продуктів. Навчитись ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення якості.

	2.2 Хід роботи 
	Виберемо три методи рефакторингу для детального розгляду. У минулих проєктах знайдемо код, що потребує рефакторингу обраними методами, опишемо причину рефакторингу, відредагуємо код та пояснемо покращення.
	Перший метод називається «Інкапсуляція колекції» (Incapsulate Collection). Цей метод рефакторингу полягає в тому, щоб інкапсулювати (тобто приховати) колекцію (масив, список, тощо) за допомогою класу чи функцій, що надають лише необхідні операції для взаємодії з даними. Таким чином, замість того, щоб безпосередньо маніпулювати колекцією, ми використовуємо спеціалізовані методи, що дозволяють контролювати доступ до елементів і змінювати внутрішню реалізацію без впливу на інші частини програми.
     В мові програмування C немає класів як в об'єктно-орієнтованих мовах, але можна досягти подібного ефекту через структури та функції для інкапсуляції. Уявімо, що маємо програму, яка працює з масивом цілих чисел і безпосередньо звертається до цього масиву в різних частинах коду:

 1 #include <stdio.h>
 2 
 3 #define MAX_SIZE 100
 4 
 5 int numbers[MAX_SIZE];
 6 int count = 0;
 7 
 8 void addNumber(int number) {
 9     if (count < MAX_SIZE) {
10         numbers[count] = number;
11         count++;
12     }
13 }
14 
15 void printNumbers() {
16     for (int i = 0; i < count; i++) {
17         printf("%d ", numbers[i]);
18     }
19     printf("\n");
20 }
21 
22 void removeNumber(int index) {
23     if (index >= 0 && index < count) {
24         for (int i = index; i < count - 1; i++) {
25             numbers[i] = numbers[i + 1];
26         }
27         count--;
28     }
29 }
30 
31 int main() {
32     addNumber(5);
33     addNumber(10);
34     addNumber(15);
35 
36     printNumbers();  
37 
38     removeNumber(1);
39 
40     printNumbers();  
41 
42     return 0;
43 }
44

	У цьому коді масив numbers і змінна count є доступними в глобальній області видимості. Код безпосередньо змінює масив і маніпулює ним, що робить програму менш гнучкою, складною для тестування та підтримки.
     Тепер давайте інкапсулюємо колекцію в структуру, щоб приховати масив від безпосереднього доступу ззовні. Створимо функції для додавання, видалення та отримання елементів масиву:

 1 #include <stdio.h>
 2 
 3 #define MAX_SIZE 100
 4 
 5 typedef struct {
 6     int numbers[MAX_SIZE];
 7     int count;
 8 } NumberCollection;
 9 
10 void initCollection(NumberCollection *collection) {
11     collection->count = 0;
12 }
13 
14 void addNumber(NumberCollection *collection, int number) {
15     if (collection->count < MAX_SIZE) {
16         collection->numbers[collection->count] = number;
17         collection->count++;
18     }
19 }
20 
21 void printNumbers(const NumberCollection *collection) {
22     for (int i = 0; i < collection->count; i++) {
23         printf("%d ", collection->numbers[i]);
24     }
25     printf("\n");
26 }
27 
28 void removeNumber(NumberCollection *collection, int index) {
29     if (index >= 0 && index < collection->count) {
30         for (int i = index; i < collection->count - 1; i++) {
31             collection->numbers[i] = collection->numbers[i + 1];
32         }
33         collection->count--;
34     }
35 }
36 
37 int main() {
38     NumberCollection collection;
39     initCollection(&collection);
40 
41     addNumber(&collection, 5);
42     addNumber(&collection, 10);
43     addNumber(&collection, 15);
44 
45     printNumbers(&collection);  
46 
47     removeNumber(&collection, 1);
48 
49     printNumbers(&collection);  
50 
51     return 0;
52 }
53
     Тепер масив numbers та змінна count знаходяться всередині структури NumberCollection. Це дозволяє приховати реалізацію колекції та захистити дані від випадкових змін. Функції addNumber, removeNumber, і printNumbers тепер працюють з об'єктами типу NumberCollection. Це дозволяє контролювати доступ до даних, наприклад, можна перевірити розмір колекції чи виконати інші перевірки перед маніпуляціями.
     Якщо в майбутньому потрібно змінити тип або реалізацію колекції (наприклад, перейти від масиву до списку або іншої структури даних), достатньо змінити тільки структуру NumberCollection і функції для роботи з нею, без потреби змінювати код у всіх місцях, де використовується ця колекція.
     Переваги рефакторингу:
   • Тепер колекція захищена від випадкових змін із зовнішнього коду.
   • Код став більш зрозумілим та структурованим, оскільки всі операції з колекцією виконуються через чітко визначені функції.
   • Легше змінювати реалізацію колекції (наприклад, перейти від масиву до списку або іншої структури), не змінюючи решту коду.
     Цей метод рефакторингу є важливим для великих програм, де зміни в одній частині коду можуть призвести до багатьох помилок через відсутність чіткої інкапсуляції.
     Другий метод називається «Переміщення методу вниз» (Push Down Method). Метод Push Down Method полягає в тому, щоб перемістити метод з батьківського класу чи більш високого рівня абстракції на більш низький рівень, до дочірнього класу або відповідної структури даних. У разі мови C це може означати переміщення функцій з більш загальної області або структури в більш спеціалізовану або локалізовану.
     Цей метод рефакторингу використовують, коли метод більше не є актуальним для класу або структури, до якого він належить, і має бути переміщений на нижчий рівень, де він буде корисним і де його виклик матиме більше сенсу.
     Розглянемо програму, яка містить функцію, що працює з даними на більш високому рівні (наприклад, структура Person), але цей метод краще було б перемістити в нижчий рівень, наприклад, в більш конкретну структуру Employee. У коді перед рефакторингом ми маємо функцію, яка не зовсім підходить для батьківської структури, але все ж її використовує:

 1 #include <stdio.h>
 2 
 3 typedef struct {
 4     char name[100];
 5     int age;
 6 } Person;
 7 
 8 typedef struct {
 9     Person person;
10     double salary;
11 } Employee;
12 
13 
14 void printSalary(Employee *emp) {
15     printf("Salary: %.2f\n", emp->salary);
16 }
17 
18 
19 void printPersonInfo(Person *person) {
20     printf("Name: %s\n", person->name);
21     printf("Age: %d\n", person->age);
22 }
23 
24 int main() {
25     Employee emp = {{"John Doe", 30}, 50000.0};
26     printPersonInfo((Person*)&emp);  
27     printSalary(&emp);               
28 
29     return 0;
30 }
31 

	У цьому коді функція printSalary працює з типом Employee, хоча вона знаходиться в контексті структури Person. Теоретично, оскільки лише Employee має поле salary, цю функцію логічно було б перемістити до структури Employee, а не використовувати в загальному контексті Person.
     Тепер давайте застосуємо метод Push Down Method. Перемістимо функцію printSalary безпосередньо до структури Employee, щоб вона була доступною тільки для об'єктів цього типу:

 1 #include <stdio.h>
 2 
 3 typedef struct {
 4     char name[100];
 5     int age;
 6 } Person;
 7 
 8 typedef struct {
 9     Person person;
10     double salary;
11 } Employee;
12 
13 
14 void printSalary(Employee *emp) {
15     printf("Salary: %.2f\n", emp->salary);
16 }
17 
18 
19 void printPersonInfo(Person *person) {
20     printf("Name: %s\n", person->name);
21     printf("Age: %d\n", person->age);
22 }
23 
24 int main() {
25     Employee emp = {{"John Doe", 30}, 50000.0};
26     printPersonInfo((Person*)&emp);  
27     printSalary(&emp);               
28 
29     return 0;
30 }
31

	Функція printSalary була переміщена до типу Employee, оскільки тільки для цієї структури є актуальною інформація про зарплату. Тепер функція printSalary є частиною структури Employee, що робить її більш відповідною для конкретного типу даних. Це також покращує читабельність і підтримку коду, оскільки методи не перебувають у непотрібних місцях, де вони не використовуються. Якщо в майбутньому з'явиться ще один тип, який буде містити поле salary (наприклад, Manager), то функцію printSalary можна буде перемістити безпосередньо до цього нового типу.
     Переваги рефакторингу:
   • Методи тепер знаходяться там, де вони реально потрібні. Це покращує логічну організацію коду та полегшує його підтримку.
   • Вилучення методів з некоректних контекстів зменшує ймовірність помилок і полегшує відслідковування помилок.
   • Якщо виникнуть нові типи, які потребують цієї ж функціональності (наприклад, Manager), функцію можна просто перемістити або розширити.
     Метод Push Down Method є корисним в об'єктно-орієнтованому програмуванні, а в мові C цей підхід можна адаптувати для роботи зі структурами даних, коли деякі функції краще реалізувати в контексті конкретних структур, а не на рівні загальних.
     Цей метод дозволяє кращу організацію коду та зменшує повторення функціональності в різних частинах програми.
     Третій метод називається «Зміна посилання на значення» (Change Reference To Value). Метод Change Reference To Value полягає в тому, щоб змінити параметри функції або змінні, що передаються за посиланням (якщо мова підтримує посилання), на параметри, що передаються за значенням. Це означає, що замість того, щоб передавати в функцію посилання на об'єкт чи змінну, ми передаємо копію цього об'єкта або значення.
     У мові C ми працюємо з вказівниками для досягнення подібного ефекту, тому цей рефакторинг зазвичай включає зміну вказівників на значення або зміну параметрів функції з вказівників на значення.
     Коли використовувати Change Reference To Value:
   • Якщо передача даних за посиланням не має істотних переваг для ефективності або функціональності.
   • Коли передача за значенням робить код більш зрозумілим і безпечним, оскільки не змінюється оригінальний об'єкт.
   • Коли потрібно уникнути непотрібних побічних ефектів, які можуть виникати при зміні значень через посилання.
     Розглянемо програму, де значення передаються за допомогою вказівників, і ми хочемо змінити це на передачу за значенням, щоб уникнути побічних ефектів:

 1 #include <stdio.h>
 2 
 3 void increment(int *num) {
 4     (*num)++;
 5 }
 6 
 7 int main() {
 8     int x = 10;
 9     increment(&x);
10     printf("Incremented value: %d\n", x);  
11 
12     return 0;
13 }
14 

     У цьому прикладі функція increment змінює значення змінної x через вказівник. Оскільки змінна x змінюється безпосередньо через посилання, можуть виникати непередбачувані побічні ефекти, якщо значення змінюється без необхідності.
     Замінимо передавання значення через вказівник на передавання значення за значенням. Це дозволить уникнути непотрібних змін оригінальної змінної та зробить код чистішим:

 1 #include <stdio.h>
 2 
 3 int increment(int num) {
 4     num++;
 5     return num;
 6 }
 7 
 8 int main() {
 9     int x = 10;
10     x = increment(x);
11     printf("Incremented value: %d\n", x); 
12 
13     return 0;
14 }
15 

     Замість того, щоб передавати вказівник на змінну x у функцію increment, ми передаємо саму змінну. Функція тепер не змінює значення змінної напряму, а повертає нове значення, яке потім присвоюється змінній x в основній функції. Коли передаємо значення за значенням, оригінальна змінна не змінюється випадковим чином, і побічні ефекти стають менш ймовірними. Це робить код більш зрозумілим і безпечним. Якщо в програмі є кілька посилань на одну й ту ж змінну, можна випадково змінити її значення в іншому місці. Передача значення за значенням допомагає уникнути таких проблем.
     Переваги рефакторингу:
   • Передача даних за значенням робить функції та програми простішими для розуміння та використання, оскільки функції не змінюють стан змінних поза своєю областю видимості.
   • Оскільки змінна передається копією, оригінальна змінна не змінюється випадково через функцію.
   • Функції, які працюють із копіями даних, мають чітко визначену поведінку, без несподіваних змін зовнішніх змінних.
     Рефакторинг Change Reference To Value робить код більш безпечним і передбачуваним. Це особливо корисно у великих програмах, де передача даних через вказівники може призвести до важко відстежуваних помилок і небажаних побічних ефектів. Однак варто зазначити, що інколи передача за посиланням може бути більш ефективною, особливо для великих структур або масивів, де передача за значенням може бути менш ефективною через копіювання великих об'єктів.
     
	Висновки
     Під час виконання практичної роботи були розглянуті основні методи рефакторингу коду. Завдяки аналізу реальних прикладів з власних проєктів, ми навчилися виявляти проблеми в коді та ефективно застосовувати методи рефакторингу, такі як Encapsulate Collection, Push Down Method і Change Reference To Value. Це дозволило зробити код більш зрозумілим, компактним, зручним для тестування та підтримки, а також знизити ймовірність виникнення помилок у майбутньому.
     Відеозапис захисту презентації можна знайти за наступним посиланням: 
https://youtu.be/OOgGnNdZVuU 

ДЖЕРЕЛА


   1. Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
   2. https://refactoring.guru
   3. https://www.freecodecamp.org/news/best-practices-for-refactoring-code
   4. 

ДОДАТОК А
Слайди презентації



Рисунок А.1 – Титульний слайд


Рисунок А.2 – Мета презентації


Рисунок А.3 – Вступ


Рисунок А.4 – Вихідний код до рефакторингу з інкапсуляцією колекції



Рисунок А.5 – Використання вихідного коду до рефакторингу з інкапсуляцією колекції


Рисунок А.6 – Вихідний код після рефакторингу з інкапсуляцією колекції

  
Рисунок А.7 – Використання вихідного коду після рефакторингу з інкапсуляцією колекції


Рисунок А.8 – Вихідний код до рефакторингу з переміщенням методу вниз
  
Рисунок А.9 – Використання вихідного коду до рефакторингу з переміщенням методу вниз


Рисунок А.10 – Рефакторинг з переміщенням методу вниз

  
Рисунок А.11 – Використання вихідного коду після рефакторингу з переміщенням методу вниз


Рисунок А.12 – Вихідний код до рефакторингу з заміною посилання на значення


Рисунок А.13 – Вихідний код після рефакторингу з заміною посилання на значення


Рисунок А.14 – Висновки


Рисунок А.15 – Використані джерела


Рисунок А.16 – Подяка за увагу




